<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="EspPacketProcessor" Id="{05be571e-be20-46fc-9aa3-6f0e1c571904}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK EspPacketProcessor IMPLEMENTS ITF_Cyclic
VAR
	
	_Udp						: ITF_UdpConnection;
	_UdpReceiveBuffer			: REFERENCE TO ARRAY [0..TCPADS_MAXUDP_BUFFSIZE - 1] OF BYTE;
	_LastCheckedIndex			: UDINT;
	_List						: ITF_LinkedList;
	_PacketsReceived			: ULINT;
	
	_Decoder					: ITF_PayloadDecoder;
	
	_ReceivedPacketType			: BYTE;
	_ReceivedPacketAddress		: PVOID;
	_ReceivedPacketLength		: UINT;
	
	_SendingPacketAddress		: PVOID;
	_SendingPacketLength		: UINT;
	
	_Payload1					: EspUdpPayload1;
	_CurrentEsp32				: ITF_EspHost;
	
	_State						: BYTE;
	_i							: BYTE;
	
END_VAR

VAR CONSTANT
	
	_StartDelimiter1			: BYTE := GVL_Udp.StartDelimiter1;
	_StartDelimiter2			: BYTE := GVL_Udp.StartDelimiter2;
	_EndDelimiter1				: BYTE := GVL_Udp.EndDelimiter1;
	_EndDelimiter2				: BYTE := GVL_Udp.EndDelimiter2;
	_PacketTypePosition			: BYTE := GVL_Udp.PacketTypePosition;
	
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Folder Name="Private" Id="{a272a727-3988-4408-abfc-67103f70209e}" />
    <Folder Name="Public" Id="{b3a90f2a-fb10-47d8-b27b-ed3a8f77b9e5}" />
    <Method Name="ClearBufferAtLocation" Id="{d451c427-ca4e-4e53-86c8-cf78b23bc920}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE ClearBufferAtLocation : BOOL
VAR_INPUT
	PacketAddress			: PVOID;
	PacketLength			: UINT;
END_VAR
VAR
	i	: UDINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF MEMSET(PacketAddress, 0, PacketLength) > 0 THEN

	ClearBufferAtLocation := TRUE;
	
ELSE
	
	ClearBufferAtLocation := FALSE;
	
END_IF

RETURN;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="ClearEntireBuffer" Id="{5b97cea3-6cfc-44ef-848d-da951801b59a}" FolderPath="Public\">
      <Declaration><![CDATA[METHOD ClearEntireBuffer : BOOL
VAR_INPUT
END_VAR
VAR
	i	: UDINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
FOR i := 0 TO TCPADS_MAXUDP_BUFFSIZE - 1 BY 1 DO

	_UdpReceiveBuffer[i] := 0;

END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="CopyPacketIntoStructure" Id="{a7cd640b-c057-4e56-87b7-444786445c11}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE CopyPacketIntoStructure : BOOL
VAR_INPUT
	PacketType				: BYTE;
	PacketAddress			: PVOID;
	PacketLength			: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE PacketType OF
	
	1:
	
		MEMCPY(ADR(_Payload1), PacketAddress, PacketLength); 
		
		_Payload1.Start := HeaderEndianSwap(_Payload1.Start);
		
		_Payload1.End := TailEndianSwap(_Payload1.End);
		
		CopyPacketIntoStructure := TRUE;
		
		
		
	2:
	
		//
	
	
	
	3:
		
		//
	
	
	
END_CASE

]]></ST>
      </Implementation>
    </Method>
    <Method Name="CreateEsp" Id="{0422dece-937d-4f2d-8f33-18aad4d44460}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE CreateEsp : ITF_EspHost
VAR_INPUT
	PacketType				: BYTE;
END_VAR
VAR
	Node	: ITF_Node;
	Ptr	: POINTER TO EspHost;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF _List.CreateNode() THEN
	
	Node := _List.GetNode(_List.GetListLength());
			
	Ptr := Node.GetMyPointer();
	
	CreateEsp := Ptr^;
	
	CASE PacketType OF
		
		1:
			
			CreateEsp.Uid := _Payload1.Start.SlaveUid;
			
			CreateEsp.EspType := _Payload1.Start.MessageType;
			
		
	END_CASE

END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="CyclicUpdate" Id="{be97351d-5c68-4a8e-a83d-1e093e85b384}" FolderPath="Public\">
      <Declaration><![CDATA[METHOD CyclicUpdate : BOOL
VAR
	hr	: HRESULT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
_Udp.CyclicUpdate();

_UdpReceiveBuffer REF= _Udp.ReceiveBufferReference;	

IF _Udp.TryOpenConnection() <> S_OK OR ADR(_UdpReceiveBuffer) = 0 OR _Decoder = 0 THEN
	
	RETURN;

END_IF



FOR _i := 0 TO 199 BY 1 DO
	
	CASE _State OF
		
		0:
		
			_CurrentEsp32 := 0;
			
			hr := TryFindPacketInBuffer(_ReceivedPacketType, _ReceivedPacketAddress, _ReceivedPacketLength);
			
			IF hr = S_OK THEN
				
				_State := 1;
				
			ELSIF hr <> S_PENDING THEN
				
				EXIT;
				
			END_IF
			
			
			
		1:
		
			IF CopyPacketIntoStructure(_ReceivedPacketType, _ReceivedPacketAddress, _ReceivedPacketLength) THEN
				
				_State := 2;
				
			END_IF
			
			
			
		2:
		
			IF ClearBufferAtLocation(_ReceivedPacketAddress, _ReceivedPacketLength) THEN
				
				_State := 3;
				
			END_IF
		
		
		
		3:
		
			_CurrentEsp32 := FindEspFromUid(_ReceivedPacketType);
		
			IF _CurrentEsp32 <> 0 THEN
				
				_State := 4;
			
			ELSE
				
				CreateEsp(_ReceivedPacketType);
				
			END_IF
			
			
			
		4:
		
			IF _CurrentEsp32.InjectPacket(_ReceivedPacketType, _ReceivedPacketAddress, _ReceivedPacketLength) THEN
				
				_State := 7;
				
			END_IF
		
		
		
		5:
		
			//_CurrentEsp32.GetResponse(_SendingPacketAddress, _SendingPacketLength);
			
			
		
		6:
		
			IF _Udp.TrySendData(_Udp.LastReceivedIp, _Udp.LastReceivedPort, _SendingPacketAddress, _SendingPacketLength) = S_OK THEN
				
				_State := 7; 
				
			END_IF
		
		
		
		7:
			
			_State := 0;
			
	END_CASE

END_FOR

























// 
// IF TryOpenConnection() = S_OK AND_THEN
// 	TryFindPacketInBuffer(_ReceivedPacketType, _ReceivedPacketLength, _ReceivedPacketLocation) = S_OK AND_THEN
// 	CopyPacketIntoStructure(_ReceivedPacketType, _ReceivedPacketLength, _ReceivedPacketLocation) AND_THEN 
// 	ClearBufferAtLocation(_ReceivedPacketLength, _ReceivedPacketLocation) THEN
// 	
// 	
// 	
// 	CASE _ReceivedPacketType OF
// 		
// 		0:
// 			;
// 			
// 		1:	// Test packet
// 			_CurrentEsp32 := FindEspFromUid(_Payload1.Start);
// 			IF _CurrentEsp32 = 0 THEN
// 				_CurrentEsp32 := CreateEsp(_Payload1.Start);
// 			END_IF
// 			_CurrentEsp32.InjectPacket(ADR(_Payload1), SIZEOF(_Payload1), 1);
// 			
// 		2:
// 			;
// 			
// 		3:
// 			;
// 			
// 	END_CASE
// 	
// 	
// 
// 	
// 
// 	
// 	
// END_IF
// 





// 
// hr1 := TryFindAPacketInBuffer(ReceivedPacketType, ReceivedPacketLength, ReceivedPacketLocation);
// 
// IF hr1 = S_OK THEN
// 	
// 	IF CopyPacketIntoStructure(ReceivedPacketType, ReceivedPacketLength, ReceivedPacketLocation) THEN
// 		
// 		ClearBufferAtLocation(ReceivedPacketLength, ReceivedPacketLocation);
// 		
// 	END_IF
// 
// END_IF

]]></ST>
      </Implementation>
    </Method>
    <Property Name="Decoder" Id="{53b1f3d7-a565-4626-ad36-d708a0989c98}">
      <Declaration><![CDATA[PROPERTY Decoder : ITF_PayloadDecoder]]></Declaration>
      <Set Name="Set" Id="{3e91f7d1-ede6-4c34-b22f-716c9521e253}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[_Decoder := Decoder;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="FB_Init" Id="{de930b98-4376-4a46-92a0-2be25d257ea9}">
      <Declaration><![CDATA[//FB_Init is always available implicitly and it is used primarily for initialization.
//The return value is not evaluated. For a specific influence, you can also declare the
//methods explicitly and provide additional code there with the standard initialization
//code. You can evaluate the return value.
METHOD FB_Init: BOOL
VAR_INPUT
    bInitRetains: BOOL; // TRUE: the retain variables are initialized (reset warm / reset cold)
    bInCopyCode: BOOL;  // TRUE: the instance will be copied to the copy code afterward (online change)   
	UdpSocket	: ITF_UdpConnection;
	EspList		: ITF_LinkedList;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[_Udp := UdpSocket;
_UdpReceiveBuffer REF= _Udp.ReceiveBufferReference;
_List := EspList;]]></ST>
      </Implementation>
    </Method>
    <Method Name="FindEspFromUid" Id="{a5acbb1d-0874-4cfb-aa5b-ecd39f0e29a6}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE FindEspFromUid : ITF_EspHost
VAR_INPUT
	PacketType				: BYTE;
END_VAR
VAR
	Length	: UINT;
	i		: UINT;
	Node	: ITF_Node;
	Ptr		: POINTER TO EspHost;
	Esp		: ITF_EspHost;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
Length := _List.GetListLength();

IF Length = 0 THEN
	
	FindEspFromUid := 0;
		
	RETURN;

END_IF

FOR i := 1 TO Length BY 1 DO

	Node := _List.GetNode(i);

	Ptr := Node.GetMyPointer();

	Esp := Ptr^;
	
	IF Esp.EspType = PacketType THEN
	
		CASE PacketType OF
			
			0:
				
			
			1:
				
				IF Esp.Uid = _Payload1.Start.SlaveUid THEN
					
					FindEspFromUid := Esp;
					
					RETURN;
					
				END_IF
				
			
		END_CASE
	
	END_IF
	
	
	
	
	
// 	
// 	IF Header.MessageType <> 0 THEN
// 		
// 		Ptr := Node.GetMyPointer();
// 	
// 		Esp := Ptr^;
// 		
// 	END_IF
// 	
// 	IF Esp = 0 THEN
// 		
// 		FindEspFromUid := 0;
// 		
// 		RETURN;
// 		
// 	END_IF
// 	
// 	Uid := Esp.Uid;
// 	
// 	IF Uid = Header.SlaveUid THEN // = uid in buffer 
// 		
// 		FindEspFromUid := Esp;
// 		
// 		RETURN;
// 		
// 	END_IF

END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="IsAcceptingData" Id="{a8556bb5-22ae-4069-9b97-75360e7225b8}" FolderPath="Public\">
      <Declaration><![CDATA[METHOD IsAcceptingData : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IsAcceptingData := _Udp.IsConnected();

RETURN;]]></ST>
      </Implementation>
    </Method>
    <Method Name="TryFindPacketInBuffer" Id="{b0962c32-b620-4d2c-8983-6c2de1d66f22}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE TryFindPacketInBuffer : HRESULT
VAR_INPUT
	PacketType				: REFERENCE TO BYTE;
	PacketAddress			: REFERENCE TO PVOID;
	PacketLength			: REFERENCE TO UINT;
END_VAR
VAR
	i						: UDINT;
	Good					: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TryFindPacketInBuffer := S_PENDING;

FOR i := _LastCheckedIndex TO TCPADS_MAXUDP_BUFFSIZE - 1 BY 1 DO
	
	IF _UdpReceiveBuffer[i] = _StartDelimiter1 AND_THEN _UdpReceiveBuffer[i + 1] = _StartDelimiter2 THEN
					
		PacketType := _UdpReceiveBuffer[i + _PacketTypePosition];
		
		PacketAddress := ADR(_UdpReceiveBuffer[i]);
		
		PacketLength := BytesToUint(_UdpReceiveBuffer[i + 2], _UdpReceiveBuffer[i + 3]);
		
		IF PacketLength = 0 OR PacketType = 0 THEN
			
			TryFindPacketInBuffer := -1;
					
		ELSIF _UdpReceiveBuffer[i + PacketLength - 2] <> _EndDelimiter1 OR _UdpReceiveBuffer[i + PacketLength - 1] <> _EndDelimiter2 THEN
			
			TryFindPacketInBuffer := S_PENDING;
			
		ELSE
			
			_PacketsReceived := _PacketsReceived + 1;
			
			Good := TRUE;
			
		END_IF
		
		EXIT;
					
	END_IF

END_FOR

IF _LastCheckedIndex > TCPADS_MAXUDP_BUFFSIZE - 1 THEN
	
	_LastCheckedIndex := 0;
	
ELSE
	
	_LastCheckedIndex := i;

END_IF

IF Good THEN
	
	TryFindPacketInBuffer := S_OK;
	
ELSE
	
	TryFindPacketInBuffer := -1;

END_IF

RETURN;]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>