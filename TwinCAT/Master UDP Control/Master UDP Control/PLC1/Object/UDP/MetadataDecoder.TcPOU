<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="MetadataDecoder" Id="{05be571e-be20-46fc-9aa3-6f0e1c571904}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK MetadataDecoder
VAR
	
	_Udp						: ITF_UdpConnection;
	_UdpReceiveBuffer			: REFERENCE TO ARRAY [0..TCPADS_MAXUDP_BUFFSIZE - 1] OF BYTE;
	_LastCheckedIndex			: UDINT;
	_PacketsReceived			: ULINT;
	
END_VAR

VAR CONSTANT
	
	_StartDelimiter1			: BYTE := GVL_Udp.StartDelimiter1;
	_StartDelimiter2			: BYTE := GVL_Udp.StartDelimiter2;
	_EndDelimiter1				: BYTE := GVL_Udp.EndDelimiter1;
	_EndDelimiter2				: BYTE := GVL_Udp.EndDelimiter2;
	_PacketTypePosition			: BYTE := GVL_Udp.PacketTypePosition;
	
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="ClearBufferAtLocation" Id="{d451c427-ca4e-4e53-86c8-cf78b23bc920}">
      <Declaration><![CDATA[METHOD ClearBufferAtLocation : BOOL
VAR_INPUT
	PacketAddress			: PVOID;
	PacketLength			: UINT;
END_VAR
VAR
	i	: UDINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF MEMSET(PacketAddress, 0, PacketLength) > 0 THEN

	ClearBufferAtLocation := TRUE;
	
ELSE
	
	ClearBufferAtLocation := FALSE;
	
END_IF

RETURN;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="CreateMetadataUpdate" Id="{17fefbae-c06e-4bc9-935f-3906d85027aa}">
      <Declaration><![CDATA[METHOD CreateMetadataUpdate : EspPacketHeader
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
MEMCPY(ADR(CreateMetadataUpdate), ADR(_UdpReceiveBuffer[0]), 48);

RETURN;]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_Init" Id="{de930b98-4376-4a46-92a0-2be25d257ea9}">
      <Declaration><![CDATA[//FB_Init is always available implicitly and it is used primarily for initialization.
//The return value is not evaluated. For a specific influence, you can also declare the
//methods explicitly and provide additional code there with the standard initialization
//code. You can evaluate the return value.
METHOD FB_Init: BOOL
VAR_INPUT
    bInitRetains: BOOL; // TRUE: the retain variables are initialized (reset warm / reset cold)
    bInCopyCode: BOOL;  // TRUE: the instance will be copied to the copy code afterward (online change)   
	UdpSocket	: ITF_UdpConnection;
	EspList		: ITF_LinkedList;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[_Udp := UdpSocket;
_UdpReceiveBuffer REF= _Udp.ReceiveBufferReference;]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetPacketUID" Id="{abe644a5-fd15-4ccf-b1f3-2e23948a2d8f}">
      <Declaration><![CDATA[METHOD GetPacketUID : ULINT
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[MEMCPY(ADR(GetPacketUID), ADR(_UdpReceiveBuffer[8]), 8);]]></ST>
      </Implementation>
    </Method>
    <Method Name="TryFindPacketInBuffer" Id="{b0962c32-b620-4d2c-8983-6c2de1d66f22}">
      <Declaration><![CDATA[METHOD TryFindPacketInBuffer : HRESULT
VAR_INPUT
	PacketType				: REFERENCE TO BYTE;
	PacketAddress			: REFERENCE TO PVOID;
	PacketLength			: REFERENCE TO UINT;
END_VAR
VAR
	i						: UDINT;
	Good					: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TryFindPacketInBuffer := S_PENDING;

IF NOT _Udp.IsConnected() OR ADR(_UdpReceiveBuffer) = 0 THEN
	
	RETURN;

END_IF

FOR i := _LastCheckedIndex TO TCPADS_MAXUDP_BUFFSIZE - 1 BY 1 DO
	
	IF _UdpReceiveBuffer[i] = _StartDelimiter1 AND_THEN _UdpReceiveBuffer[i + 1] = _StartDelimiter2 THEN
					
		PacketType := _UdpReceiveBuffer[i + _PacketTypePosition];
		
		PacketAddress := ADR(_UdpReceiveBuffer[i]);
		
		PacketLength := BytesToUint(_UdpReceiveBuffer[i + 2], _UdpReceiveBuffer[i + 3]);
		
		IF PacketLength = 0 OR PacketType = 0 THEN
			
			TryFindPacketInBuffer := -1;
					
		ELSIF _UdpReceiveBuffer[i + PacketLength - 2] <> _EndDelimiter1 OR _UdpReceiveBuffer[i + PacketLength - 1] <> _EndDelimiter2 THEN
			
			TryFindPacketInBuffer := S_PENDING;
			
		ELSE
			
			_PacketsReceived := _PacketsReceived + 1;
			
			Good := TRUE;
			
		END_IF
		
		EXIT;
					
	END_IF

END_FOR

IF _LastCheckedIndex > TCPADS_MAXUDP_BUFFSIZE - 1 THEN
	
	_LastCheckedIndex := 0;
	
ELSE
	
	_LastCheckedIndex := i;

END_IF

IF Good THEN
	
	TryFindPacketInBuffer := S_OK;
	
ELSE
	
	TryFindPacketInBuffer := -1;

END_IF

RETURN;]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>