<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="Application" Id="{e755b4b3-663e-4aba-9984-5644739ccf72}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM Application
VAR CONSTANT
	Port 					: UDINT := 10050;
END_VAR
VAR
	UdpWin10				: UdpWindowsSocket('192.168.137.1', Port);
	UdpRt					: UdpRealtimeSocket(Port);
	Udp						: ITF_UdpConnection := UdpRt;
	
	EspFactory				: EspHostFactory;
	List					: List(EspFactory);
	
	DataDecoder				: DataDecoder(Udp, List);
	UpdaterRegistry			: UpdaterRegistry;
	TestUpdater				: Updater_TestPacket;
	
	Init					: BOOL := FALSE;
	i						: BYTE;
	j						: UINT;
	State					: BYTE;
	hr						: HRESULT;

	ReceivedIP				: T_IPv4Addr;
	InputHeader				: EspPacketHeader;	
	TempEspPtr				: POINTER TO EspHost;
	TempEsp					: ITF_EspHost;
	TempEspHeader			: EspPacketHeader;
	
	PacketToSendAdr			: PVOID;
	PacketToSendLength		: UDINT;
	
	ReceivedPacketType		: BYTE;
	ReceivedPacketAddress	: PVOID;
	ReceivedPacketLength	: UINT;
	ReceivedDataLength		: UINT;
	
	PacketsProcessed		: ULINT;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[
IF NOT Init THEN

	IF Udp.TryOpenConnection() <> S_OK THEN
		
		RETURN;
	
	END_IF

	UpdaterRegistry.TryRegister(TestUpdater);
	
	Init := TRUE;

END_IF





// Multiple processing calls per cycle are possible

FOR i := 0 TO 9 BY 1 DO
	
	Udp.CyclicUpdate();
	
	CASE State OF
		
		0:	// Is data available
			
			hr := DataDecoder.TryFindPacketInBuffer(ReceivedPacketType, ReceivedPacketAddress, ReceivedPacketLength, ReceivedDataLength);
			
			IF hr = S_OK THEN
				
				ReceivedIP := UdpRt.LastReceivedIp;
				
				State := 1;
				
			ELSIF hr <> S_PENDING THEN
				
				EXIT;
				
			END_IF
			
	

		1:	// Decode header
		
			InputHeader := DataDecoder.GetPacketHeader();

			IF InputHeader.SlaveUid = 0 THEN
				
				// Clear buffer
				
				State := 0;
				
			END_IF
			
			State := 2;



		2:	// Check CRC
		
			// CRC Check Function on TargetHeader
			
			// If fail, clear buffer, state := 0
			
			State := 3;



		3:	// Find UID in list
		
			IF List.GetListLength() = 0 THEN
				
				State := 4;
				
			END_IF
		
			FOR j := 1 TO List.GetListLength() BY 1 DO
			
				TempEspPtr := List.GetNode(j).GetMyPointer();
				
				IF TempEspPtr = 0 THEN
					
					// No matching device in list, create
					
					State := 4;
					
				ELSE
					
					// Check if correct UID
					
					TempEsp := TempEspPtr^;
				
					TempEspHeader := TempEsp.GetMetadata();
					
					IF InputHeader.SlaveUid = TempEspHeader.SlaveUid THEN
						
						State := 5;
						
						EXIT;
						
					END_IF
					
				END_IF
				
			END_FOR	
			
			IF j = List.GetListLength() + 1 THEN
				
				State := 4;
				
			END_IF
			
			
			
		4:	// Create device in list
			
			IF List.CreateNode() THEN
						
				TempEspPtr := List.GetNode(List.GetListLength()).GetMyPointer();
				
				TempEsp := TempEspPtr^;
				
				TempEsp.SetUID(InputHeader.SlaveUid);
				
				TempEsp.SetEspType(ReceivedPacketType);
				
				State := 5;
			
			END_IF
			
			
			
		5:	// Apply data
		
			IF TempEsp.UpdateMetadata(InputHeader) THEN
				
				IF TempEsp.GetPacketToSend(PacketToSendAdr, PacketToSendLength) THEN
					
					State := 6;

				ELSE
					
					State := 7;
	
				END_IF
				
			END_IF
		
		
		
		6:	// Send data
		
			hr := UdpRt.TrySendData(ReceivedIP, Port, PacketToSendAdr, PacketToSendLength);
			
			IF hr <> S_PENDING AND SUCCEEDED(hr) THEN
				
				State := 7;
				
			ELSIF FAILED(hr) THEN
				
				State := 8;
				
			END_IF
		
		
		
		7:	// System function OK
			
			ReceivedIP := '';
			MEMSET(ADR(InputHeader), 0, 48);
			TempEspPtr := 0;
			TempEsp := 0;
			MEMSET(ADR(TempEspHeader), 0, 48);
			DataDecoder.ClearBufferAtLocation(ReceivedPacketAddress, ReceivedPacketLength);
			
			PacketsProcessed := PacketsProcessed + 1;
			State := 0;
			
			
		
		
		8:	// System RX OK, TX FAIL
		
// 		
// 		
// 		
// 		5:
// 		
// 			hr := TempUpdater.TryApplyPayload(ReceivedPacketAddress, ReceivedPacketLength, TempEsp);
// 			
// 			IF hr <> S_PENDING AND SUCCEEDED(hr) THEN
// 				
// 				TempEsp.UpdateMetadata(DataDecoder.CreateMetadataUpdate());
// 				
// 				DataDecoder.ClearBufferAtLocation(ReceivedPacketAddress, ReceivedPacketLength);
// 				
// 				ReceivedPacketAddress := 0;
// 				ReceivedPacketLength := 0;
// 				ReceivedPacketType := 0;
// 			
// 				TargetEspUID := 0;
// 				TempEspPtr := 0;	
// 				TempEsp := 0;
// 				MEMSET(ADR(TempEspHeader), 0, SIZEOF(TempEspHeader));
// 				TempUpdater := 0;
// 				
// 				State := 0;
// 				
// 			END_IF
// 		
// 		
// 			
// 			
// 		1:
// 		
// 			TempUpdater := UpdaterRegistry.ResolveUpdater(ReceivedPacketType, 1);
// 			
// 			IF TempUpdater = 0 THEN
// 				
// 				;// ERROR
// 				
// 			END_IF
// 			
// 			State := 2;
// 			
// 		
// 		
// 		2:
// 		
// 			TargetEspUID := DataDecoder.GetPacketUID();
// 			
// 			IF TargetEspUID = 0 THEN
// 				
// 				;// ERROR
// 				
// 			END_IF
// 			
// 			State := 3;
// 			
// 			
// 			
// 		3:
// 		
// 			FOR j := 1 TO List.GetListLength() BY 1 DO
// 			
// 				TempEspPtr := List.GetNode(j).GetMyPointer();
// 			
// 				TempEsp := TempEspPtr^;
// 				
// 				TempEspHeader := TempEsp.GetMetadata();
// 				
// 				IF TargetEspUID = TempEspHeader.SlaveUid THEN
// 					
// 					FoundEsp := TRUE;
// 					
// 					EXIT;
// 					
// 				END_IF
// 				
// 			END_FOR
// 			
// 			IF FoundEsp THEN
// 				
// 				FoundEsp := FALSE;
// 				
// 				State := 5;
// 				
// 			ELSE
// 				
// 				State := 4;
// 				
// 			END_IF
// 			
// 			
// 			
// 		4:
// 			
// 			IF List.CreateNode() THEN
// 						
// 				TempEspPtr := List.GetNode(List.GetListLength()).GetMyPointer();
// 				
// 				TempEsp := TempEspPtr^;
// 				
// 				TempEsp.SetUID(TargetEspUID);
// 				
// 				TempEsp.SetEspType(ReceivedPacketType);
// 				
// 				State := 5;
// 			
// 			END_IF
// 		
// 		
// 		
// 		5:
// 		
// 			hr := TempUpdater.TryApplyPayload(ReceivedPacketAddress, ReceivedPacketLength, TempEsp);
// 			
// 			IF hr <> S_PENDING AND SUCCEEDED(hr) THEN
// 				
// 				TempEsp.UpdateMetadata(DataDecoder.CreateMetadataUpdate());
// 				
// 				DataDecoder.ClearBufferAtLocation(ReceivedPacketAddress, ReceivedPacketLength);
// 				
// 				ReceivedPacketAddress := 0;
// 				ReceivedPacketLength := 0;
// 				ReceivedPacketType := 0;
// 			
// 				TargetEspUID := 0;
// 				TempEspPtr := 0;	
// 				TempEsp := 0;
// 				MEMSET(ADR(TempEspHeader), 0, SIZEOF(TempEspHeader));
// 				TempUpdater := 0;
// 				
// 				State := 0;
// 				
// 			END_IF
			
	END_CASE

END_FOR
]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>